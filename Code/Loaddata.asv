function [Nav, Spk, Lfp] = Loaddata(Loadparams)
%Load behavior, spike times and LFP data into Nav, Spk and Lfp structures

%%
%loading position data
S = load([Loadparams.Datafolder filesep Loadparams.posfilename]);

%Converting positions from pixels to cm
Nav.Xpos = Loadparams.pix2cm * S.positions(:,2);
Nav.Ypos = Loadparams.pix2cm * S.positions(:,3);
Nav.sampleTimes = S.positions(:,1);

%%
%loading subsessions indices
catevents = LoadEvents([Loadparams.Datafolder filesep Loadparams.catevtfilename]);
%Filling in the Nav.Condition vector with 1 for preprun, 2 for presleep, 3
%for run, 4 for postsleep, 5 for postrun
Nav.Condition = NaN(size(Nav.Xpos));
for idx = 1:2:numel(catevents.timestamps)
    strmatch = regexp(catevents.description{idx},{'-prerun','-presleep','-run','-postsleep','-postrun'});
    condID = find(~cellfun(@isempty,strmatch));
    condidx = Nav.sampleTimes >= catevents.timestamps(idx) & Nav.sampleTimes <= catevents.timestamps(idx + 1);
    Nav.Condition(condidx) = condID;
end

%%
%Computing a few additional behavioral metrics (Speed, acceleration,
%direction of mvt?). These need to be computed for each sessions seperately
%since recording are discontinous between sessions
Nav.Spd = NaN(size(Nav.Xpos));
Nav.XDir = NaN(size(Nav.Xpos));
sampleRate_orig = mean(diff(Nav.sampleTimes), 'omitnan');
smthwin = 0.5 * sampleRate_orig;%500 ms smoothing window for sped and direction
spd_th = 5;%cm
for icond = 1:5
    idxcond = find(Nav.Condition == icond);
    Xdiff = [diff(Nav.Xpos(idxcond)) ; NaN];
    Ydiff = [diff(Nav.Ypos(idxcond)) ; NaN];
    Tdiff = [diff(Nav.sampleTimes(idxcond)) ; Nav.sampleTimes(idxcond(end)) - Nav.sampleTimes(idxcond(end - 1))];
    Nav.Spd(idxcond) = medfilt1(sqrt(Xdiff.^2 + Ydiff.^2)./Tdiff, smthwin);
    Xspd = medfilt1(Xdiff ./ Tdiff, smthwin);
    XDirLtoR = medfilt1(double(Xspd > spd_th), smthwin);
    Nav.XDir(idxcond) = medfilt1(double(Xspd, smthwin) < 5/50),41)
end

%%
%Resampling behavioral data to the final resolution (Loadparams.sampleRate) 
sampleTimes_orig = Nav.sampleTimes;
sampleTimes_new = (min(sampleTimes_orig):(1/Loadparams.sampleRate):max(sampleTimes_orig))';
Nav.Xpos = interp1(sampleTimes_orig, Nav.Xpos, sampleTimes_new, 'linear'); 
Nav.Ypos = interp1(sampleTimes_orig, Nav.Ypos, sampleTimes_new, 'linear');
Nav.Spd = interp1(sampleTimes_orig, Nav.Spd, sampleTimes_new, 'linear');
Nav.Condition = interp1(sampleTimes_orig, Nav.Condition, sampleTimes_new, 'nearest');
Nav.sampleTimes = sampleTimes_new;


%%
%loading information about types of lap (left to right, right to left). 
%Nav.laptype equals 1 or -1 for left to right and right to left trials
%respectively.
Nav.laptype = zeros(size(Nav.Xpos));
Nav.uturn = zeros(size(Nav.Xpos));
LapType = load([Loadparams.Datafolder filesep Loadparams.laptypefilename]);
for idx = 1:size(LapType.LtoRlaps, 1)
    Nav.laptype(Nav.sampleTimes >= LapType.LtoRlaps(idx,1) & Nav.sampleTimes <= LapType.LtoRlaps(idx,2)) = 1;
end
for idx = 1:size(LapType.RtoLlaps, 1)
    Nav.laptype(Nav.sampleTimes >= LapType.RtoLlaps(idx,1) & Nav.sampleTimes <= LapType.RtoLlaps(idx,2)) = -1;
end

%Nav.uturn = 1 when the rat makes a uturn before the end f the trial.
%Nav.laptype equals zero when when the rats makes a u-turn before the end.
for idx = 1:size(LapType.Uturnlaps, 1)
    Nav.uturn(Nav.sampleTimes >= LapType.Uturnlaps(idx,1) & Nav.sampleTimes <= LapType.Uturnlaps(idx,2)) = 1;
end


%%
%loading left/right reward times and filling in Nav.reward with 1 for right
%reward and -1 for left reward
Nav.reward = zeros(size(Nav.Xpos));
rrwevents = LoadEvents([Loadparams.Datafolder filesep Loadparams.rrwevtfilename]);
lrwevents = LoadEvents([Loadparams.Datafolder filesep Loadparams.lrwevtfilename]);
for idx = 1:numel(rrwevents.timestamps)
    [~, rewidx] = min(abs(Nav.sampleTimes - rrwevents.timestamps(idx)));
    Nav.reward(rewidx) = 1;
end
for idx = 1:numel(lrwevents.timestamps)
    [~, rewidx] = min(abs(Nav.sampleTimes - lrwevents.timestamps(idx)));
    Nav.reward(rewidx) = -1;
end

%%
%loading air puffs timestamps and filling in Nav.airpuff with 1 when there
%is an air puff
Nav.airpuff = zeros(size(Nav.Xpos));
Loadparams.pufevtfilename = [Loadparams.animalname '-' num2str(Loadparams.session) '.puf.evt'];
pufevents = LoadEvents([Loadparams.Datafolder filesep Loadparams.pufevtfilename]);
for idx = 1:numel(pufevents.timestamps)
    [~, puffidx] = min(abs(Nav.sampleTimes - pufevents.timestamps(idx)));
    Nav.airpuff(puffidx) = 1;
end

%%
%Loading accelerometer data
acc = matfile([Loadparams.Datafolder filesep Loadparams.accfilename]);

%Sample times for the accelerometer
accsampleTimes = acc.acc(:,1);

%Resampling the 3 accelerometer channels at the final sampling rate
sampleTimes_orig = accsampleTimes;
sampleTimes_new = Nav.sampleTimes;
Nav.acc = interp1(sampleTimes_orig, acc.acc(:,2:end), sampleTimes_new, 'linear');

%%
%loading spike times and cluster ID from the prepared .mat file
S = load([Loadparams.Datafolder filesep Loadparams.spkfilename]);

%convert spike times into an array of spike trains, at the same resolution
%as the behavioral data. We assume the behavioral data and the spike
%recording have already been aligned together
clustList = unique(S.HippoSpikes(:,2));
ncells = max(clustList);
nTimeSamples = numel(Nav.sampleTimes);

Spk.spikeTrain = zeros(nTimeSamples, ncells);
binEdges = [Nav.sampleTimes ; max(Nav.sampleTimes) + 1/Loadparams.sampleRate];

for icell = clustList(:)'
    try
    spktimes_temp = S.HippoSpikes(S.HippoSpikes(:,2) == icell,1);
    catch
        keyboard
    end
    Spk.spikeTrain(:,icell) = histcounts(spktimes_temp, binEdges);
end
Spk.sampleTimes = Nav.sampleTimes;

%Saving some cluster info into the Spk structure
S = load([Loadparams.Datafolder filesep Loadparams.spkinfofilename]);
HippoClustidx = ismember(S.IndexType(:,3), Loadparams.ShankList);
Spk.shankID = S.IndexType(HippoClustidx,3)';
Spk.PyrCell = (S.IndexType(HippoClustidx,6) == 1)';
Spk.IntCell = (S.IndexType(HippoClustidx,6) == 2)';

%%
%loading ripples timestamps and filling in Lfp.ripple with 1 when there
%is a ripple and Lfp.ripplepeak with 1 for the peak of each ripple
Lfp.sampleTimes = Nav.sampleTimes;
Lfp.ripple = zeros(size(Nav.Xpos));
Lfp.ripplepeak = zeros(size(Nav.Xpos));
ripevents = LoadEvents([Loadparams.Datafolder filesep Loadparams.ripevtfilename]);
ripstart = ripevents.timestamps(contains(ripevents.description,'start'));
ripstop = ripevents.timestamps(contains(ripevents.description,'stop'));
rippeak = ripevents.timestamps(contains(ripevents.description,'peak'));
for idx = 1:numel(ripstart)
    Lfp.ripple(Nav.sampleTimes >= ripstart(idx) & Nav.sampleTimes <= ripstop(idx)) = 1;
    [~, rippeakidx] = min(abs(Nav.sampleTimes - rippeak(idx)));
    Lfp.ripplepeak(rippeakidx) = 1;
end


%%
%loading eeg states timestamps (wake, rem, nrem) and filling in
%Lfp.eegstate with 1 for wake, 0 for drowsy, -1 for REM sleep and -2 for
%non-REM sleep.
Lfp.state = NaN(size(Nav.Xpos));
States = load([Loadparams.Datafolder filesep Loadparams.statefilename]);
for idx = 1:size(States.wake, 1)
    Lfp.state(Nav.sampleTimes >= States.wake(idx,1) & Nav.sampleTimes <= States.wake(idx,2)) = 1;
end
for idx = 1:size(States.drowsy, 1)
    Lfp.state(Nav.sampleTimes >= States.drowsy(idx,1) & Nav.sampleTimes <= States.drowsy(idx,2)) = 0;
end
for idx = 1:size(States.sws, 1)
    Lfp.state(Nav.sampleTimes >= States.sws(idx,1) & Nav.sampleTimes <= States.sws(idx,2)) = -2;
end
for idx = 1:size(States.Rem, 1)
    Lfp.state(Nav.sampleTimes >= States.Rem(idx,1) & Nav.sampleTimes <= States.Rem(idx,2)) = -1;
end

%%
%Loading Lfp oscillations
lfp = matfile([Loadparams.Datafolder filesep Loadparams.lfpfilename]);
lfpsampleTimes = lfp.hippoLFPs(:,1);
lfpsampRate = 1 / nanmean(diff(lfpsampleTimes));

%Resampling raw LFPs at the final sampling rate
sampleTimes_orig = lfpsampleTimes;
sampleTimes_new = Nav.sampleTimes;
Lfp.LfpHpc = interp1(sampleTimes_orig, lfp.hippoLFPs(:,1 + Loadparams.LfpChannel_Hpc), sampleTimes_new, 'linear');
Lfp.LfpBla = interp1(sampleTimes_orig, lfp.blaLFPs(:,1 + Loadparams.LfpChannel_Bla), sampleTimes_new, 'linear');

%Filtering in the theta band
Lfp.ThetaRaw = filterLFP(lfp.hippoLFPs(:,1 + Loadparams.LfpChannel_Hpc), Loadparams.ThetaBand(1), Loadparams.ThetaBand(2), lfpsampRate);

%Computing Hilbert transform of the filtered signal to get the phasepower
%and instantaneous frequency of Theta oscillations
hilbertTrans = hilbert(Lfp.ThetaRaw);
phs = angle(hilbertTrans);
pow = abs(hilbertTrans);

Lfp.ThetaPhase = mod(phs / pi * 180, 360);
Lfp.ThetaPower = pow;
Lfp.ThetaFreq = [0 ; diff(unwrap(phs)) * lfpsampRate / (2*pi)];

%Resampling Theta at the final sampling rate
Lfp.ThetaRaw = interp1(sampleTimes_orig, Lfp.ThetaRaw, sampleTimes_new, 'linear');
Lfp.ThetaPhase = mod(interp1(sampleTimes_orig, unwrap(Lfp.ThetaPhase / 180 * pi), sampleTimes_new, 'linear') / pi * 180, 360); 
Lfp.ThetaPower = interp1(sampleTimes_orig, Lfp.ThetaPower, sampleTimes_new, 'linear');
Lfp.ThetaFreq = interp1(sampleTimes_orig, Lfp.ThetaFreq, sampleTimes_new, 'linear');

%%
%We then need some function to compute and plots behavior. For instance,
%compute speed profile
end